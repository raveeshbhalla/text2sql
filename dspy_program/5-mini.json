{
    "accuracy": 0.574,
    "avg_latency_s": 0.33906054133400904,
    "correct": 287,
    "failures": [
        {
            "feedback": "The two queries are not functionally equivalent. The golden SQL counts accommodation records (COUNT(a.id)) for hearing-impaired students in the past year, so a student with multiple accommodations would be counted multiple times. The candidate SQL counts distinct hearing-impaired students who received at least one accommodation in the past year (COUNT(DISTINCT s.id)), so each student is counted only once. The date expressions are equivalent in purpose (one uses DATE_SUB(CURRENT_DATE, INTERVAL 1 YEAR), the other uses date('now','-1 year')), but that does not change the substantive difference in what is being counted.",
            "idx": 2,
            "pred_sql": "SELECT COUNT(DISTINCT s.id) AS hearing_students_with_accommodations_past_year FROM student s JOIN accommodation a ON s.id = a.student_id WHERE s.disability = 'Hearing Impairment' AND a.date >= date('now','-1 year');",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\n- The golden query returns a single row with the aggregate MAX(avg_temperature) and MAX(avg_salinity). It also selects the column name without aggregation or GROUP BY, which makes the returned name indeterminate (and not guaranteed to be the ocean(s) that have those maxima).\n- The candidate query returns two rows: one identifying the ocean that has the highest avg_temperature and one identifying the ocean that has the highest avg_salinity (with labels and the corresponding values). The candidate therefore explicitly reports which ocean corresponds to each maximum, whereas the golden query reports only the maximum values (and an unreliable name).\n\nBecause they produce different result shapes and the candidate explicitly finds the ocean names for each maximum while the golden query does not reliably do so, they are not functionally similar.",
            "idx": 3,
            "pred_sql": "SELECT 'highest_avg_temperature' AS metric, name, avg_temperature AS value FROM oceans WHERE avg_temperature = (SELECT MAX(avg_temperature) FROM oceans) UNION ALL SELECT 'highest_avg_salinity' AS metric, name, avg_salinity AS value FROM oceans WHERE avg_salinity = (SELECT MAX(avg_salinity) FROM oceans);",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden query returns the 3-quarter moving average for every region_id and every incident_quarter (i.e., a row per quarter with the window AVG). The candidate computes the same window AVG but then filters to keep only the row where incident_quarter = max_q per region (the most recent quarter), and also rounds/renames the column. Because the candidate returns only the last quarter per region rather than all quarters, it is not functionally equivalent to the golden query. The rounding/alias differences are minor, but the filtering to only the latest quarter is a substantive semantic change.",
            "idx": 8,
            "pred_sql": "SELECT region_id, incident_quarter AS last_quarter, ROUND(avg_3q,2) AS moving_avg_last_3 FROM (SELECT region_id, incident_quarter, AVG(incident_count) OVER (PARTITION BY region_id ORDER BY incident_quarter ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS avg_3q, MAX(incident_quarter) OVER (PARTITION BY region_id) AS max_q FROM incident_data) t WHERE incident_quarter = max_q ORDER BY region_id;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\nDifferences:\n- Column filtered: the golden SQL filters I.region = 'South America' (an attribute of the instructor). The candidate filters c.location = 'South America' (an attribute of the course). Those are different predicates and can return different sets of instructors.\n- DISTINCT: the candidate uses SELECT DISTINCT i.name to remove duplicates; the golden does not, so it may produce duplicate names if an instructor taught multiple matching courses. (This affects results even when the same rows are selected.)\n- Semantics vs prompt: the prompt asks for instructors who have taught in South America; that aligns with c.location, but the golden query uses I.region instead. Regardless of which matches the prompt better, the two queries are not functionally similar.\n\nTherefore they are not equivalent in general.",
            "idx": 10,
            "pred_sql": "SELECT DISTINCT i.name FROM Instructors i JOIN Courses c ON i.id = c.instructor_id WHERE c.course_type = 'traditional art' AND c.location = 'South America';",
            "reason": "mismatch"
        },
        {
            "feedback": "Both queries insert a row with start_location = 'Chinatown' and end_location = 'Airport'. However, the golden SQL inserts a fixed route_id = 2, while the candidate computes route_id as COALESCE(MAX(route_id),0)+1 (next-highest id). That produces different route_id values depending on the current contents of bus_routes (e.g., if the table is empty the candidate inserts route_id = 1, not 2). Because the inserted route_id can differ and the queries are not guaranteed to produce the same result in all states, they are not functionally equivalent.",
            "idx": 11,
            "pred_sql": "INSERT INTO bus_routes(route_id, start_location, end_location) SELECT COALESCE(MAX(route_id),0)+1, 'Chinatown', 'Airport' FROM bus_routes;",
            "reason": "mismatch"
        },
        {
            "feedback": "The candidate query is not functionally equivalent to the golden query. Key differences:\n- Date windows are different: the golden SQL requires start_date IN H1 2022 and end_date IN H2 2022. The candidate requires end_date IN H1 2022 and checks end_date > start_date + 6 months (so reversed H1/H2 placement).\n- The golden filters planned = FALSE (a required condition); the candidate does not filter by planned at all.\n- The golden returns project names; the candidate returns id, project, start_date, end_date (different projection).\n- The candidate attempts to identify \"defense\" projects via lower(project) LIKE '%defen%', whereas the golden uses the planned flag to identify the relevant projects \u2014 these are different selection criteria.\nBecause of these incompatible date ranges and different filtering logic, the two queries are not functionally similar.",
            "idx": 13,
            "pred_sql": "SELECT id,project,start_date,end_date FROM projects WHERE lower(project) LIKE '%defen%' AND end_date BETWEEN DATE '2022-01-01' AND DATE '2022-06-30' AND end_date > start_date + INTERVAL '6 months';",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\n- The candidate query correctly filters rows to the last 5 years (year >= current_year - 4) and returns one summed total_funding per region for that 5-year window.\n- The golden query cross-joins generate_series(1,5) and groups by that sequence, producing multiple rows per region (one per sequence value) and a years_ago column. It does not apply a WHERE filter tying the sequence to the table's year, so it does not produce the same single total per region for the last 5 years. Its intent appears different (a per-year breakdown) and its behavior differs from the candidate.\n\nTherefore they are not functionally similar.",
            "idx": 16,
            "pred_sql": "SELECT region, SUM(funding) AS total_funding FROM conservation_funding WHERE year >= EXTRACT(YEAR FROM CURRENT_DATE) - 4 GROUP BY region ORDER BY total_funding DESC;",
            "reason": "mismatch"
        },
        {
            "feedback": "The WHERE clauses are equivalent (country IN (...) is the same as country = ... OR ... and both use hectares > 1000000). However the projections differ: the golden SQL returns only forests.name while the candidate returns id, name, hectares, country. Because the selected columns differ, the queries are not functionally identical.",
            "idx": 17,
            "pred_sql": "SELECT id, name, hectares, country FROM forests WHERE country IN ('Canada','USA') AND hectares > 1000000;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries produce different results and are not functionally equivalent.\n\n- Golden SQL: uses a window function to produce a row per measurement (id, reactor_temp_time) and the cumulative average of reactor_temp up to that time. Output example from the provided data:\n  - id=1, 08:00 -> avg_reactor_temp = 120.5\n  - id=1, 09:00 -> avg_reactor_temp = (120.5+122.3)/2 = 121.4\n  - id=2, 08:00 -> avg_reactor_temp = 125.3\n\n- Candidate SQL: returns one summary row per id (first and last measurement times and temperatures), computes a simple overall trend (increasing/decreasing/stable) and the temperature difference between first and last readings. Output example:\n  - id=1 -> first_temp=120.5, last_temp=122.3, trend='increasing', temp_change=1.8\n  - id=2 -> first_temp=125.3, last_temp=125.3, trend='stable', temp_change=0.0\n\nMajor differences:\n- Golden provides a cumulative average at each timestamp (multiple rows per id); candidate provides a single summary row per id comparing first vs last readings.\n- Golden uses a window aggregation; candidate uses grouping + self-joins to find first/last rows and a CASE to classify trend.\n- The columns and semantics differ (cumulative average vs first/last comparison), so they do not implement the same functionality.\n\nTherefore they are not similar.",
            "idx": 18,
            "pred_sql": "SELECT t.id, ft.reactor_temp AS first_temp, ft.reactor_temp_time AS first_time, lt.reactor_temp AS last_temp, lt.reactor_temp_time AS last_time, CASE WHEN lt.reactor_temp>ft.reactor_temp THEN 'increasing' WHEN lt.reactor_temp<ft.reactor_temp THEN 'decreasing' ELSE 'stable' END AS trend, (lt.reactor_temp - ft.reactor_temp) AS temp_change FROM (SELECT id, MIN(reactor_temp_time) AS first_time, MAX(reactor_temp_time) AS last_time FROM production_runs GROUP BY id) t JOIN production_runs ft ON ft.id=t.id AND ft.reactor_temp_time=t.first_time JOIN production_runs lt ON lt.id=t.id AND lt.reactor_temp_time=t.last_time ORDER BY t.id;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\n- The golden query computes a single scalar: the overall minimum co_ownership_percentage across all properties that have more than one distinct co_owner_id (it filters property_id by HAVING COUNT(DISTINCT co_owner_id) > 1, then takes MIN over those rows).\n- The candidate query returns a row per property (property_id, MIN(co_ownership_percentage)) for each property that has more than one row (HAVING COUNT(*) > 1). That yields per-property minima rather than a single global minimum.\n- Also the candidate uses COUNT(*) instead of COUNT(DISTINCT co_owner_id); that may differ if duplicate co_owner_id rows exist.\n\nWith the provided data, the candidate would return two rows (101 -> 50.0, 102 -> 25.0) while the golden query would return a single value 25.0. Therefore they are not similar.",
            "idx": 20,
            "pred_sql": "SELECT property_id, MIN(co_ownership_percentage) AS min_co_ownership_percentage FROM co_ownership_agreements GROUP BY property_id HAVING COUNT(*) > 1;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\n- Golden SQL: groups by hotel_category and by day (DATE_TRUNC), then returns hotel_category and AVG(success_count) for each day-group but only for days with more than one row (HAVING COUNT(*) > 1). It excludes days with a single record and does not compute a single average across days \u2014 it yields per-day averages (one row per day group that passes the HAVING).\n- Candidate SQL: first sums success_count per day (daily total for Luxury), then computes the average of those daily totals across all days. This yields a single average number (including days with only one record) representing average successful commands per day.\n\nBecause the golden query filters out single-row days and produces per-day group averages rather than a single average across days, the candidate's result (average of daily totals) is not the same.",
            "idx": 22,
            "pred_sql": "SELECT AVG(daily_success) AS avg_success_per_day FROM (SELECT command_date, SUM(success_count) AS daily_success FROM voice_commands WHERE hotel_category = 'Luxury' GROUP BY command_date) AS daily_totals;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\nDifferences:\n- Aggregation: the golden SQL uses AVG(co2_emission) (average CO2 per row), while the candidate computes SUM(co2_emission)/SUM(visitors) (CO2 per visitor). The candidate matches the prompt's intent (\"per international tourist\"); the golden does not.\n- Date filter: the golden query filters visit_date = '2022-01-01' (one specific date). The candidate filters EXTRACT(YEAR FROM visit_date)=2022 (all of 2022). These produce different row sets.\n- The candidate also handles division by zero (NULLIF) and adds ORDER BY, neither of which affect equivalence but reinforce different behavior.\n\nBecause of the different calculations and different date filtering, they are not functionally similar.",
            "idx": 26,
            "pred_sql": "SELECT continent, SUM(co2_emission)*1.0/NULLIF(SUM(visitors),0) AS avg_co2_per_visitor FROM international_tourists WHERE EXTRACT(YEAR FROM visit_date)=2022 GROUP BY continent ORDER BY continent;",
            "reason": "mismatch"
        },
        {
            "feedback": "Both queries compute the distinct species count and the earliest observation date per station (they use COUNT(DISTINCT species_id) and MIN(observation_date)). However there are important differences:\n\n- Join type: the golden query uses an INNER JOIN (excludes stations with no observations). The candidate uses a LEFT JOIN (includes stations with zero observations with count = 0 and NULL earliest date). This changes the result set when stations have no observations.\n- Grouping/columns: the candidate groups by ms.id, ms.name, ms.location and returns extra columns (id and location) and an ORDER BY; the golden groups only by name and returns only the name plus the aggregates. Grouping by id is actually safer, but the extra columns mean the output schema differs.\nBecause the LEFT vs INNER join changes which stations appear, and the candidate returns additional columns, the two queries are not functionally equivalent to the golden query.",
            "idx": 27,
            "pred_sql": "SELECT ms.id AS station_id, ms.name AS station_name, ms.location AS station_location, COUNT(DISTINCT so.species_id) AS unique_species_count, MIN(so.observation_date) AS earliest_observation_date FROM monitoring_stations ms LEFT JOIN species_observations so ON ms.id = so.station_id GROUP BY ms.id, ms.name, ms.location ORDER BY ms.id;",
            "reason": "mismatch"
        },
        {
            "feedback": "The candidate is not functionally equivalent. Differences:\n- The golden query requires an exact match WHERE name = 'Rust' (and uses a scalar subquery for contract_id). The candidate uses WHERE LOWER(s.name) LIKE '%rust%', which is case-insensitive and will match any name containing \"rust\" (e.g., \"Rusty\", \"rust-lang\", \"MyRustContract\"), returning a superset of results.\n- The candidate uses a JOIN (which handles multiple matching contracts), while the golden query's scalar subquery would fail or behave differently if multiple smart_contracts had name = 'Rust'.\n- The column alias change (d.name AS dapp_name) is only cosmetic.\n\nBecause of the differing match semantics (exact equality vs. substring/case-insensitive match) and different behavior with multiple smart_contract rows, they are not functionally similar.",
            "idx": 28,
            "pred_sql": "SELECT d.dapp_id, d.name AS dapp_name FROM blockchain_domain.decentralized_applications d JOIN blockchain_domain.smart_contracts s ON d.smart_contract_id = s.contract_id WHERE LOWER(s.name) LIKE '%rust%';",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\nDifferences:\n- The golden SQL filters companies by mc.continent = 'Asia' (intended to restrict to a continent), while the candidate uses an explicit country list WHERE e.employee_country IN ('Israel','Saudi Arabia'). These are different filters (and the golden's continent filter is broader/wrong for \"Middle East\" and also references a non-existent column in the provided schema).\n- The golden enforces e.employee_country = mc.country in the WHERE clause; the candidate does not check that employee_country matches the company's country (it relies only on the join by company_id). That can produce different groupings if employee_country and company country differ.\n- The golden groups by mc.country; the candidate groups by e.employee_country. Those are equivalent only when employee_country = mc.country; otherwise results differ.\n- The candidate also adds ORDER BY total_employees DESC, which changes result ordering (not present in golden).\n\nBecause of these semantic differences (different filters and missing equality condition), they are not functionally similar.",
            "idx": 32,
            "pred_sql": "SELECT e.employee_country AS country, SUM(e.num_employees) AS total_employees FROM employees e JOIN mining_companies m ON e.company_id = m.id WHERE e.employee_country IN ('Israel','Saudi Arabia') GROUP BY e.employee_country ORDER BY total_employees DESC;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries are not functionally equivalent.\n\nMain differences:\n- Source of \"Bus\" filtering: the golden SQL filters on v.Service = 'Bus' in a Vehicles table (join on VehicleID). The candidate infers \"bus\" by VehicleType LIKE '%Bus%' within MaintenanceIncidents. Those are different predicates and can produce different rows (and the context shows no Vehicles table exists, so the golden query is referencing a table not present).\n- Time window: the golden SQL uses IncidentDate >= DATEADD(month, -1, GETDATE()) (last month relative to current date). The candidate uses a window based on the data's MAX(IncidentDate) (MAX(...) and subtract 1 month), i.e., last month relative to the dataset's latest incident. These will normally differ.\n- Result cardinality/intent: the golden query returns counts for all vehicle types ordered descending (no LIMIT); the candidate adds LIMIT 1 to return only the top type.\n- Candidate's date expression is nonstandard/likely incorrect SQL syntax (DATE((SELECT MAX...), '-1 month')), so behavior/portability differs.\n\nBecause of these semantic differences (filter source, timeframe reference, and result selection), the candidate is not functionally similar to the golden SQL.",
            "idx": 33,
            "pred_sql": "SELECT VehicleType, COUNT(*) AS incidents FROM MaintenanceIncidents WHERE VehicleType LIKE '%Bus%' AND IncidentDate BETWEEN DATE((SELECT MAX(IncidentDate) FROM MaintenanceIncidents), '-1 month') AND (SELECT MAX(IncidentDate) FROM MaintenanceIncidents) GROUP BY VehicleType ORDER BY incidents DESC LIMIT 1;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries differ in the string used to exclude US-made products: the golden SQL checks country_of_manufacture != 'United States' while the candidate checks country_of_manufacture <> 'US'. The <> operator is equivalent to !=, so the logical operator on is_on_sale is the same, but 'US' and 'United States' are different literal values. Therefore the candidate will not exclude rows where country_of_manufacture = 'United States' (because 'United States' <> 'US' is true), so it is not functionally equivalent to the golden query.",
            "idx": 34,
            "pred_sql": "SELECT product_name, price FROM products WHERE country_of_manufacture <> 'US' AND is_on_sale = FALSE;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden query (as written) computes COUNT(DISTINCT visitor_id) over jazz events in New Orleans divided by the same COUNT(DISTINCT visitor_id) \u2014 which always yields 100 (unless NULL/zero handling differs). In contrast, the candidate query:\n\n- Groups by visitor_id for jazz events in New Orleans,\n- Counts how many distinct visitors had cnt > 1 (repeat_visitors),\n- Divides repeat_visitors by the number of distinct visitors to produce the percentage of repeat attendees (with rounding and a zero-division guard).\n\nThese are different computations. With the provided data (visitor_ids 1,2,3,4 each appearing once), the candidate returns 0.0 (no repeat visitors) while the golden query returns 100. Therefore they are not functionally similar.",
            "idx": 37,
            "pred_sql": "SELECT CASE WHEN totals.total_visitors=0 THEN 0 ELSE ROUND(100.0 * repeats.repeat_visitors / totals.total_visitors, 2) END AS repeat_percentage FROM (SELECT SUM(CASE WHEN cnt>1 THEN 1 ELSE 0 END) AS repeat_visitors, COUNT(*) AS total_visitors FROM (SELECT visitor_id, COUNT(*) AS cnt FROM Visitors WHERE city='New Orleans' AND event_name LIKE '%Jazz%' GROUP BY visitor_id) AS per_visitor) AS repeats CROSS JOIN (SELECT (SELECT COUNT(*) FROM (SELECT visitor_id FROM Visitors WHERE city='New Orleans' AND event_name LIKE '%Jazz%' GROUP BY visitor_id) AS v) AS total_visitors) AS totals;",
            "reason": "mismatch"
        },
        {
            "feedback": "The two queries produce different results:\n\n- The golden SQL returns a single scalar count of all members who signed up in the last 30 days (one row with total COUNT(*)). (Note: its ORDER BY sign_up_date is semantically incorrect for a single aggregate but does not change that it aims to return a single total.)\n- The candidate SQL returns one row per sign_up_date (daily counts) for the last 30 days, i.e., multiple rows with columns (sign_up_date, new_fans), ordered by date.\n\nBecause one returns a single total and the other returns per-day counts, they are not functionally equivalent despite both filtering by the last 30 days and using equivalent date-interval syntax.",
            "idx": 40,
            "pred_sql": "SELECT sign_up_date, COUNT(*) AS new_fans FROM fan_club_members WHERE sign_up_date >= (CURRENT_DATE - INTERVAL '30' DAY) GROUP BY sign_up_date ORDER BY sign_up_date;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden query counts distinct site names (COUNT(DISTINCT site)), while the candidate counts rows (COUNT(*)). If the table can contain multiple rows for the same site, the candidate may overcount. Although with the provided data both queries return the same numeric result (one Italy row and one Greece row), they are not functionally equivalent in general because of the missing DISTINCT.",
            "idx": 41,
            "pred_sql": "SELECT COUNT(*) AS count_sites FROM ExcavationSites WHERE location IN ('Italy','Greece');",
            "reason": "mismatch"
        }
    ],
    "total": 500
}