{
    "accuracy": 0.736,
    "avg_latency_s": 0.1709705568339996,
    "correct": 368,
    "failures": [
        {
            "feedback": "The golden SQL query uses a common table expression (CTE) with an UPDATE statement and then inserts the affected rows back into the same table. This is an unusual and likely incorrect approach for updating a value, as it tries to insert rows back into the table after updating them, which may lead to errors or duplicate entries if the primary key is not changed or not handled properly.\n\nThe candidate SQL query is a straightforward UPDATE statement that sets the 'troops' value to 850 for the row where the country is 'Afghanistan' and the year is 2005. This is the standard and correct way to update a row in a table.\n\nFunctionally, both queries intend to update the troops value for the specific record. However, the golden query is overly complicated and possibly erroneous due to the unnecessary INSERT after the UPDATE. The candidate query correctly performs the intended update operation straightforwardly and effectively.\n\nSince the candidate query performs the functional update as intended, while the golden query attempts an UPDATE but then tries to insert the updated rows back into the table (which is generally incorrect or redundant), they differ in functional behavior and correctness.",
            "idx": 4,
            "pred_sql": "UPDATE peacekeeping_operations SET troops = 850 WHERE country = 'Afghanistan' AND year = 2005;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query retrieves users' names, their data sharing status, and specifically filters for users who have location sharing set to true within their sharing_preferences JSON field. It joins the privacy_settings table with a users table and filters on the specific JSON attribute for location sharing, effectively showing only those users who share their location data.\n\nThe candidate SQL query selects all columns from privacy_settings without filtering or joining to the users table, and does not extract or filter on any specific sharing preference. Therefore, the candidate query does not limit the results to users who are sharing location data nor provide user names.\n\nThese queries therefore serve different purposes: the golden SQL drills down specifically into users sharing location data with user names, while the candidate SQL provides a broad, unfiltered view of all privacy settings.\n\nHence, the candidate SQL query is not functionally similar to the golden SQL query.",
            "idx": 9,
            "pred_sql": "SELECT user_id, data_sharing, sharing_preferences FROM privacy_settings;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query correctly categorizes menu items into two groups: 'Vegetarian' and 'Non-Vegetarian' by using a CASE statement. Items with category 'Vegetarian' are grouped under 'Vegetarian', and all other categories fall under 'Non-Vegetarian'. It then sums the prices to get the total revenue for these two broad categories.\n\nThe candidate SQL query groups by the original \"Category\" column and sums the prices. This means it will have separate rows for all existing categories, including 'Vegetarian' and 'Meat' (or any other categories), rather than grouping all non-vegetarian items together as \"Non-Vegetarian\".\n\nSince the prompt asks for the total revenue for vegetarian and non-vegetarian items, the candidate query does not properly consolidate all non-vegetarian items into one group, unlike the golden query. Thus, the candidate query does not produce the same functional result as the golden query.",
            "idx": 17,
            "pred_sql": "SELECT Category, SUM(Price) AS total_revenue FROM MenuItems GROUP BY Category;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query calculates the average number of trainings held per year in California by selecting the average of training_count values filtered by 'California' grouped by year. It averages the training_count per row for each year.\n\nThe candidate SQL query first calculates the total number of trainings per year in California by summing training_count grouped by year, then calculates the average of these yearly totals. This approach correctly aggregates training counts per year before averaging across years.\n\nThe key difference is that the golden SQL does not sum training_count per year before averaging, so it averages the training_count values directly per row within each year, which may not be correct if multiple rows per year exist. The candidate SQL properly sums per year first then averages, which is the appropriate way to find the average number of trainings per year.\n\nThus, the candidate SQL provides the correct functionality implied by the prompt, while the golden SQL's result may be incorrect if multiple rows exist per year.\n\nTherefore, they are not functionally similar.",
            "idx": 21,
            "pred_sql": "SELECT AVG(yearly_training) AS average_trainings_per_year FROM (SELECT year, SUM(training_count) AS yearly_training FROM DisasterPreparedness WHERE state = 'California' GROUP BY year) AS yearly_totals;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query returns each individual healthcare service within each region along with a rank based on the service name within that region (using ROW_NUMBER() partitioned by Region and ordered by Service). This effectively enumerates each service per region.\n\nThe candidate SQL query, on the other hand, aggregates the data by region, counting the number of services in each region (COUNT(Service) AS service_count), and then ranks the regions based on the service count using RANK() OVER (ORDER BY COUNT(Service) DESC). This aggregates to one row per region, showing total service count and regional ranking based on availability.\n\nThe user's prompt requests: \"How many healthcare services are available in each region, and what is their ranking based on availability?\" The candidate query directly addresses this with total counts and ranking of regions by availability.\n\nThe golden query, while showing each service and a ranking within each region, does not produce per-region counts or a ranking of the regions by service availability.\n\nHence, the two queries answer related but different questions and produce different result formats.\n\nTherefore, they are not functionally similar.",
            "idx": 22,
            "pred_sql": "SELECT Region, COUNT(Service) AS service_count, RANK() OVER (ORDER BY COUNT(Service) DESC) AS availability_rank FROM HealthcareServices GROUP BY Region;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query groups the hospitals by location and calculates both the sum and the average number of beds for each location, providing a distribution breakdown. The candidate SQL groups by location and calculates the total beds per location but also adds an additional row with the overall total beds across all locations. The candidate does not provide the average number of beds per location, nor does it provide the distribution in the exact same format as the golden SQL. While both queries address the sum of beds by location, the golden SQL gives average beds as an additional metric, and the candidate gives a grand total row instead. Thus, the candidate query is not functionally similar because the outputs and metrics differ.",
            "idx": 26,
            "pred_sql": "SELECT location, SUM(num_beds) AS total_beds FROM hospitals GROUP BY location UNION ALL SELECT 'Total' AS location, SUM(num_beds) FROM hospitals;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query tries to find the maximum number of observations by selecting the maximum value of number_of_observations per day (grouped by ocean and day) between specific dates (2000-01-01 and 2022-12-31). However, the use of MAX(number_of_observations) with a GROUP BY ocean and DATE_TRUNC('day', observation_date) does not produce the total number of species observed in a day but rather the maximum single observation count within that day for Baltic Sea.\n\nIn contrast, the candidate SQL query computes the total number of observations per day in the Baltic Sea by summing number_of_observations per observation_date and then selects the maximum daily total across all days. This approach aligns better with the natural language prompt \u2014 \"maximum number of marine species ever observed in a single day\" \u2014 by summing observations within the day rather than just taking the max single record.\n\nThere is a difference in date range filtering, as the golden SQL restricts to dates between 2000-01-01 and 2022-12-31, while the candidate does not apply any date restriction. This could affect the result if data outside that date range exists.\n\nFunctionally, the candidate is closer to the intent of the query by summing the daily observations to get total counts per day and then finding the maximum sum across days. The golden SQL only finds the maximum observation for a single record per day, which could underestimate the total daily count.\n\nDue to this significant difference in aggregation logic (MAX of single observations vs. MAX of sums per day), their results can differ, and they are not functionally equivalent.",
            "idx": 29,
            "pred_sql": "SELECT MAX(daily_total) AS max_observations FROM (SELECT observation_date, SUM(number_of_observations) AS daily_total FROM marine_species_observations WHERE ocean = 'Baltic Sea' GROUP BY observation_date) sub;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query attempts to calculate the average serving size of dishes meeting some protein threshold, but it has multiple issues: it uses a correlated subquery \"(SELECT serving_size * 0.3)\" without referencing a table properly, and the grouping by protein with HAVING COUNT(*) > 0 is nonsensical and unnecessary for this purpose. The intention seems to be to filter dishes where protein is at least 30% of their serving size, but the query syntax and logic are flawed. \n\nThe candidate SQL query filters dishes with protein >= 50 and then calculates the average serving size of those dishes. This is simple, and explicitly matches a threshold for protein amount (>=50), while the golden query intends a dynamic threshold based on serving_size * 0.3 but does so incorrectly.\n\nFunctionally, the candidate and golden queries do not do the same:\n- The candidate uses a fixed protein threshold (50).\n- The golden query attempts to use a threshold of 30% of serving size (protein >= serving_size * 0.3), but does so incorrectly.\n\nTherefore, the candidate query is not functionally similar to the golden query. Moreover, the golden query is syntactically problematic and would not run successfully, but even interpreting the intended logic, the candidate query's logic differs significantly.",
            "idx": 35,
            "pred_sql": "SELECT AVG(serving_size) AS avg_serving_size FROM dishes WHERE protein >= 50;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query selects only the port_name from the ports table where the crane_capacity is greater than 150. The candidate SQL query selects port_id, port_name, and crane_capacity for the same condition. While both queries filter on the crane_capacity > 150 condition correctly, the result columns differ. The prompt asks to \"List all the ports,\" which can be interpreted as listing port names only, but the candidate query lists additional columns. Therefore, the candidate query returns more information than required, which means it is not functionally equivalent because the output format is different from the golden query. \nHence, they are not functionally similar as per the prompt's expected output.",
            "idx": 40,
            "pred_sql": "SELECT port_id, port_name, crane_capacity FROM ports WHERE crane_capacity > 150;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL provides a join operation between the HeritageSites and Countries tables on the country name, which is a crucial step if the prompt's intention is to retrieve combined information from both tables. The candidate SQL, however, only creates the HeritageSites table without performing any join or data retrieval operation. Since the candidate SQL does not include any join or implies any subsequent data extraction or manipulation that the golden SQL shows, the candidate does not fulfill the same functional purpose as the golden SQL.",
            "idx": 46,
            "pred_sql": "CREATE TABLE HeritageSites (Site VARCHAR(50), CountryName VARCHAR(50));",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL uses location LIKE checks for prefixes 'Middle East%' or 'North Africa%', assuming these are location values representing those regions. However, given the data context, locations are country names like 'Saudi Arabia' and 'Kuwait', not region names prefixed with 'Middle East' or 'North Africa'. Therefore, the golden SQL likely returns no rows or incorrect aggregation, because no location literally starts with those prefixes.\n\nThe candidate SQL lists specific countries from the Middle East and North Africa explicitly in the location IN clause and filters for shariah_compliant = TRUE. This approach aligns better with the data provided since locations are country names. It sums assets for those where the institution is Shariah-compliant and located in those countries.\n\nTherefore, functionally, the candidate SQL correctly captures Shariah-compliant institutions in specified Middle East and North African countries, whereas the golden SQL likely does not due to its filtering by prefixes which don\u2019t match the actual location values.\n\nDespite the discrepancy in how the region is filtered, the intent is the same: sum assets of Shariah-compliant institutions in Middle East and North Africa. The candidate SQL more correctly implements the intent given the data.\n\nThus, the candidate SQL and golden SQL are *not* functionally equivalent because the golden SQL\u2019s filtering condition is incorrect or ineffective for the given data, while the candidate SQL is accurate.",
            "idx": 47,
            "pred_sql": "SELECT SUM(assets) AS total_assets FROM financial_institutions WHERE shariah_compliant = TRUE AND location IN ('Saudi Arabia', 'Kuwait', 'United Arab Emirates', 'Qatar', 'Bahrain', 'Oman', 'Jordan', 'Lebanon', 'Egypt', 'Morocco', 'Tunisia', 'Algeria', 'Libya', 'Sudan', 'Iraq', 'Palestine', 'Syria', 'Yemen')",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query calculates the average of the eco_friendly boolean values directly from the tours table joined with hotels, filtering only those tours that are eco-friendly and associated with Paris hotels. Since eco_friendly is a boolean, aggregating AVG on eco_friendly effectively computes the fraction of tours that are eco-friendly (1 for true, 0 for false), so the result is the proportion of eco-friendly tours among all tours in Paris.\n\nHowever, the natural language prompt asks for the average number of eco-friendly tours offered per hotel in Paris. The candidate SQL query correctly counts the number of eco-friendly tours per Paris hotel (counting tours with eco_friendly = true per hotel), then averages this count across all Paris hotels. This matches the prompt better because it represents the mean count of eco-friendly tours per hotel, rather than the fraction of eco-friendly tours.\n\nThe golden query's use of AVG(t.eco_friendly) actually returns the fraction of eco-friendly tours among all tours (which may differ from the average number of eco-friendly tours per hotel). For example, a hotel with many tours and a hotel with none impact the average in different ways.\n\nTherefore, the candidate SQL matches the user prompt more accurately, while the golden SQL can be interpreted as a related but different metric. They are not functionally equivalent queries answering the same question.",
            "idx": 55,
            "pred_sql": "SELECT AVG(tour_count) AS avg_eco_friendly_tours_per_hotel FROM (SELECT h.id, COUNT(t.id) AS tour_count FROM hotels h LEFT JOIN tours t ON h.id = t.hotel_id AND t.eco_friendly = true WHERE h.city = 'Paris' GROUP BY h.id) sub;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query attempts to filter the downtime values based on a date condition, specifically that the downtime is greater than or equal to a date 6 months ago from the current date. However, this logic is incorrect since the 'downtime' column is a decimal representing the number of downtime days, not a date or timestamp that can be compared to a date expression like DATE_SUB(CURDATE(), INTERVAL 6 MONTH). This suggests a conceptual mistake in the golden SQL's WHERE clause. The candidate SQL query simply selects the maximum downtime value from the Equipment table without any date filtering, which makes logical sense given the available data schema and the prompt asking for the maximum downtime experienced in the last 6 months. Since there is no date or time data in the table to filter on when the downtime occurred, the candidate SQL retrieves the max downtime over all the entries. Functionally, given the table structure, the candidate SQL is correct and the golden SQL is flawed. Therefore, functionally they differ, as the golden SQL's condition is invalid or nonsensical in this context and would result in an empty or erroneous result.",
            "idx": 62,
            "pred_sql": "SELECT MAX(downtime) AS max_downtime_days FROM Equipment;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query selects the maximum rating value from the Action_Games table along with the Game_Name, but it does not correctly associate the maximum rating specifically with the game name. In most SQL engines, this query would produce an arbitrary Game_Name along with the maximum rating, which might not be the correct highest-rated game. The candidate SQL query, however, correctly finds the game(s) with the maximum rating by filtering the rows where Rating equals the maximum rating, ensuring the correct game name and rating pair is returned. Functionally, the candidate query provides the correct answer as intended by the prompt, while the golden query might not. Hence, they are not functionally equivalent.",
            "idx": 65,
            "pred_sql": "SELECT Game_Name, Rating FROM Action_Games WHERE Rating = (SELECT MAX(Rating) FROM Action_Games);",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL calculates the average of the round_number values directly from the funding_records table joined with companies filtered by industry 'Fintech' and founder_age > 40. This approach averages the round_number associated with each funding record, which may not represent the true average number of funding rounds per company, especially if round_number is not incrementally continuous per company or if multiple records exist per round.\n\nThe candidate SQL first groups by company and counts the distinct number of funding rounds per company (using COUNT DISTINCT of round_number), then averages these counts across companies, including companies with zero funding rounds (using LEFT JOIN and COALESCE to handle nulls).\n\nThe candidate SQL better captures the intended meaning of \"average number of funding rounds for companies,\" because it counts how many distinct rounds each company has had, then averages that count. The golden SQL averages round_number values from all records, which may not accurately reflect the average count of rounds per company.\n\nHence, although both queries attempt to answer the prompt, their results can differ. The candidate SQL aligns more accurately with the natural language prompt's intent. Therefore, they are not functionally equivalent.",
            "idx": 73,
            "pred_sql": "SELECT AVG(COALESCE(round_count,0)) AS avg_funding_rounds FROM (SELECT c.company_id, COUNT(DISTINCT fr.round_number) AS round_count FROM companies c LEFT JOIN funding_records fr ON c.company_id = fr.company_id WHERE c.industry = 'Fintech' AND c.founder_age > 40 GROUP BY c.company_id) sub;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query dynamically generates the visitor_id by selecting the maximum visitor_id currently in the table and adding 1 to it, ensuring unique visitor_id values that increment sequentially. It uses CURDATE() to insert the current date. The candidate SQL query inserts a fixed visitor_id value of 1, which might lead to a primary key conflict if visitor_id 1 already exists in the table. It uses CURRENT_DATE, which is functionally equivalent to CURDATE() in terms of getting the current date. The main difference is in how visitor_id is assigned: the golden query is designed to avoid duplicate primary keys by incrementing the maximum existing id, while the candidate query simply inserts a constant value. Because of this, the candidate query could cause errors or data integrity issues, and therefore is not functionally the same as the golden query.",
            "idx": 76,
            "pred_sql": "INSERT INTO audience (visitor_id, name, country, visit_date) VALUES (1, 'Alex', 'USA', CURRENT_DATE);",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query selects defense projects that were not completed in 2021 by filtering for projects whose end_date is after 2021-12-31 (i.e., completed after 2021). It implicitly excludes projects completed in the year 2021 or any projects with missing end_date.\n\nThe candidate SQL query retrieves projects with end_date NULL, or with end_date before 2021, or with end_date after 2021. This includes projects never completed (end_date NULL), completed before 2021, or completed after 2021. \n\nSince the prompt says \"Which defense projects were not completed in 2021?\", projects with end_date NULL (not completed at all), those completed before 2021, and those completed after 2021 all qualify as not completed in 2021. Therefore, the candidate query is more comprehensive.\n\nThe golden query only filters for projects completed after 2021, excluding those never completed or completed before 2021, which should also be counted as \"not completed in 2021.\"\n\nThus, the candidate SQL is functionally different from the golden SQL query because the candidate query includes a broader set of projects not completed in 2021, while the golden query only includes projects ending after 2021.\n\nHence, they are not functionally similar.",
            "idx": 79,
            "pred_sql": "SELECT id, project_name, start_date, end_date FROM DefenseProjects WHERE end_date IS NULL OR end_date < '2021-01-01' OR end_date > '2021-12-31';",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query returns the name along with the maximum number of home runs by using an aggregate function directly: SELECT name, MAX(home_runs) FROM baseball_stats;. However, this query will not work correctly if there are multiple players since it aggregates home_runs but does not group by name; it actually returns one row with an arbitrary player name and the maximum home_runs value.\n\nThe candidate SQL query uses a subquery to first find the maximum number of home runs and then selects the name(s) and home_runs matching that maximum value, which correctly returns all players who have the highest home runs.\n\nFunctionally, the candidate query correctly returns the player(s) with the highest home run count, while the golden query is faulty as it combines an aggregate with a non-aggregated column without GROUP BY and thus potentially returns invalid results.\n\nTherefore, the candidate query is functionally correct and semantically aligns with the prompt, whereas the golden is flawed.\n\nThus, the candidate and golden queries are not functionally similar.",
            "idx": 80,
            "pred_sql": "SELECT name, home_runs FROM baseball_stats WHERE home_runs = (SELECT MAX(home_runs) FROM baseball_stats);",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query filters the sales data to include only products in the category 'Natural' by using the condition `product_category = 'Natural'`, focusing specifically on natural cosmetics. It groups the data by region and quarter to provide quarterly sales trends for natural cosmetics in France and Germany.\n\nThe candidate SQL query, however, does not include any filtering by `product_category = 'Natural'`. Therefore, it aggregates sales for all products in France and Germany, not just natural cosmetics. Additionally, the candidate query also extracts the year, which is not requested in the prompt or present in the golden SQL. Although it groups by year, quarter, and region, the extra year component is an extension rather than a direct contradiction, but the key difference is the lack of filtering by product category.\n\nBecause the candidate query does not filter to only natural cosmetics, it is not functionally equivalent and will produce different results than the golden SQL query.",
            "idx": 83,
            "pred_sql": "SELECT EXTRACT(YEAR FROM sale_date) AS year, EXTRACT(QUARTER FROM sale_date) AS quarter, region, SUM(sales) AS total_sales FROM sales WHERE region IN ('France', 'Germany') GROUP BY year, quarter, region ORDER BY year, quarter, region;",
            "reason": "mismatch"
        },
        {
            "feedback": "The golden SQL query calculates the difference in average salary by subtracting the average male salary from the average female salary. It does this by first computing the average salary for female employees in the main query, and then subtracting the average salary for male employees obtained via a subquery.\n\nThe candidate SQL query calculates the difference by computing the average salary of males and females using conditional aggregation inside a single query: it calculates the average salary of males (using CASE WHEN gender = 'Male' THEN salary END) and subtracts the average salary of females (CASE WHEN gender = 'Female' THEN salary END).\n\nFunctionally, both queries compute the difference between the average salary of males and females, though the candidate query computes it as (avg male - avg female), while the golden query does (avg female - avg male).\n\nBecause the candidate query subtracts average female salary from average male salary, but the golden query subtracts average male salary from average female salary, the sign of the result will be the opposite. Therefore, these queries are not functionally equivalent as they yield results with opposite signs.\n\nTherefore, the candidate query is not functionally similar to the golden query.",
            "idx": 87,
            "pred_sql": "SELECT AVG(CASE WHEN gender = 'Male' THEN salary END) - AVG(CASE WHEN gender = 'Female' THEN salary END) AS average_salary_difference FROM employees;",
            "reason": "mismatch"
        }
    ],
    "total": 500
}